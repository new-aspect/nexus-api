## MVP1 - 核心中继验证

### 用户故事 - 验证核心中继

* 标题：硅基流动 API 转发
* 概述：作为本地开发者，我想要调用我的中继服务并使用硅基流动API Key, 所以我可以验证nexus-api的核心转发机制的技术可行性。补充openai的API因为区域问题不方便，所以选用硅基流动API

### 验收标准 - 成功与失败的定义

1. 正常场景
   * 我的服务在本地运行，硬编码或配置了有效的硅基流动 API Key。
   * 当我向 http://localhost:3000/v1/chat/completions 发送一个合法的请求。
   * 那么服务成功返回一个包含模型回复的 JSON 响应。

2. 异常场景 1 (Key 错误)：
   * 我的服务在本地运行，硬编码或配置了无效的硅基流动 API Key
   * 我向服务发送请求。
   * 服务返回一个表示“鉴权失败”或“无效 Key”的 HTTP 错误码和信息。

3. 异常场景 2 (请求体错误)：
   * 给定：我的服务在本地运行。
   * 当：我发送一个缺少 messages 字段的非法请求。
   * 那么：服务返回一个表示“请求体格式错误”的 HTTP 400 错误码。

---                     

## MVP2 - 渠道管理

### 用户故事 - 验证核心中继
* 标题：API 渠道的增删改查
* 概述：作为服务管理员，我想要通过API来添加、查看、更新和删除不同的上游渠道（比如不同的模型供应商或同一个提供商的不同key）,所以我可以灵活的配置和管理服务，为未来多渠道路由和负载均衡做准备

### 验收标准 - 成功与失败的定义
1. 正常场景 1 (创建渠道)
   * 给定：我的服务在本地运行
   * 当：我想/api/channel发送一个POST请求，请求体包含一个渠道的必要信息（例如：type:"OpenAI",name:"我的备用key",key:"sk-xxxx"）
   * 那么：服务成功在数据库中创建一个新的渠道记录，并返回一个表示成功的 HTTP 状态码（201 Created）和新创建渠道的信息（不应包含完整的 key）。

2. 正常场景 2 (获取渠道列表)
   * 给定：服务中已经存在几个渠道。
   * 当：我向 /api/channel 发送一个 GET 请求。
   * 那么：服务成功返回一个包含所有渠道信息的列表。出于安全考虑，列表中的每个渠道 key 字段都应该是被遮蔽的（例如：sk-xxxx...xxxx）。

3. 正常场景 3 (更新渠道)
   * 给定：服务中已存在一个 ID 为 1 的渠道。
   * 当：我向 /api/channel/1 发送一个 PUT 请求，请求体中包含需要更新的字段（例如：{ "name": "我的主力Key" }）。
   * 那么：服务成功更新该渠道的信息，并返回更新后的渠道信息。

4. 正常场景 4 (删除渠道)
   * 给定：服务中已存在一个 ID 为 1 的渠道。
   * 当：我向 /api/channel/1 发送一个 DELETE 请求。
   * 那么：服务成功地从数据库中删除该渠道，并返回一个表示成功的 HTTP 状态码（204 No Content）。

5. 异常场景 1 (创建渠道时缺少关键信息)
   * 给定：我的服务在本地运行。
   * 当：我发送一个创建渠道的 POST 请求，但请求体中缺少了 key 字段。
   * 那么：服务返回一个表示“请求体格式错误”的 HTTP 400 错误码和相应的错误信息。
     
提示：
* 为什么是这个 MVP？ 这个步骤将你的项目从一个“写死的转发器”变成了一个“可配置的转发平台”的雏形。它引入了数据库操作和基础的 CRUD API，这是构建更复杂功能（如用户系统、令牌管理等）的基石。
* 关注点：在这个阶段，你的重点是实现渠道模型的定义、数据库的连接与操作、以及一套完整的 RESTful API。暂时还不需要让转发逻辑（MVP1 的功能）立即用上这些渠道，我们先把管理功能做好。
* 下一步是什么？ 当这个 MVP 完成后，下一个自然的步骤（MVP3）就是将 MVP1 和 MVP2 连接起来：修改你的核心中继逻辑，使其不再使用硬编码的 Key，而是能够根据请求的某些规则（例如请求头中的认证信息）从数据库中选择一个合适的渠道进行转发。