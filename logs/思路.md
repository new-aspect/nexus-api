## MVP1 - 核心中继验证

### 用户故事 - 验证核心中继

* 标题：硅基流动 API 转发
* 概述：作为本地开发者，我想要调用我的中继服务并使用硅基流动API Key, 所以我可以验证nexus-api的核心转发机制的技术可行性。补充openai的API因为区域问题不方便，所以选用硅基流动API

### 验收标准 - 成功与失败的定义

1. 正常场景
   * 我的服务在本地运行，硬编码或配置了有效的硅基流动 API Key。
   * 当我向 http://localhost:3000/v1/chat/completions 发送一个合法的请求。
   * 那么服务成功返回一个包含模型回复的 JSON 响应。

2. 异常场景 1 (Key 错误)：
   * 我的服务在本地运行，硬编码或配置了无效的硅基流动 API Key
   * 我向服务发送请求。
   * 服务返回一个表示“鉴权失败”或“无效 Key”的 HTTP 错误码和信息。

---                     

## MVP2 - 渠道管理

### 用户故事 - 验证核心中继
* 标题：API 渠道的增删改查
* 概述：作为服务管理员，我想要通过API来添加、查看、更新和删除不同的上游渠道（比如不同的模型供应商或同一个提供商的不同key）,所以我可以灵活的配置和管理服务，为未来多渠道路由和负载均衡做准备

### 验收标准 - 成功与失败的定义
1. 正常场景 1 (创建渠道)
   * 给定：我的服务在本地运行
   * 当：我想/api/channel发送一个POST请求，请求体包含一个渠道的必要信息（例如：type:"OpenAI",name:"我的备用key",key:"sk-xxxx"）
   * 那么：服务成功在数据库中创建一个新的渠道记录，并返回一个表示成功的 HTTP 状态码（201 Created）和新创建渠道的信息（不应包含完整的 key）。

2. 正常场景 2 (获取渠道列表)
   * 给定：服务中已经存在几个渠道。
   * 当：我向 /api/channel 发送一个 GET 请求。
   * 那么：服务成功返回一个包含所有渠道信息的列表。出于安全考虑，列表中的每个渠道 key 字段都应该是被遮蔽的（例如：sk-xxxx...xxxx）。

3. 正常场景 3 (更新渠道)
   * 给定：服务中已存在一个 ID 为 1 的渠道。
   * 当：我向 /api/channel/1 发送一个 PUT 请求，请求体中包含需要更新的字段（例如：{ "name": "我的主力Key" }）。
   * 那么：服务成功更新该渠道的信息，并返回更新后的渠道信息。

4. 正常场景 4 (删除渠道)
   * 给定：服务中已存在一个 ID 为 1 的渠道。
   * 当：我向 /api/channel/1 发送一个 DELETE 请求。
   * 那么：服务成功地从数据库中删除该渠道，并返回一个表示成功的 HTTP 状态码（204 No Content）。

5. 异常场景 1 (创建渠道时缺少关键信息)
   * 给定：我的服务在本地运行。
   * 当：我发送一个创建渠道的 POST 请求，但请求体中缺少了 key 字段。
   * 那么：服务返回一个表示“请求体格式错误”的 HTTP 400 错误码和相应的错误信息。
     
提示：
* 为什么是这个 MVP？ 这个步骤将你的项目从一个“写死的转发器”变成了一个“可配置的转发平台”的雏形。它引入了数据库操作和基础的 CRUD API，这是构建更复杂功能（如用户系统、令牌管理等）的基石。
* 关注点：在这个阶段，你的重点是实现渠道模型的定义、数据库的连接与操作、以及一套完整的 RESTful API。暂时还不需要让转发逻辑（MVP1 的功能）立即用上这些渠道，我们先把管理功能做好。
* 下一步是什么？ 当这个 MVP 完成后，下一个自然的步骤（MVP3）就是将 MVP1 和 MVP2 连接起来：修改你的核心中继逻辑，使其不再使用硬编码的 Key，而是能够根据请求的某些规则（例如请求头中的认证信息）从数据库中选择一个合适的渠道进行转发。

---
太棒了！恭喜你完成了 MVP2，你的项目现在已经从一个简单的“转发器”演进成了一个具备基础管理能力的“平台”了。这为我们接下来的工作打下了坚实的基础。

现在，我们要做的就是把 MVP1（核心转发）和 MVP2（渠道管理）这两个独立的功能模块连接起来，让它们真正协同工作。这正是 MVP3 的核心任务。

---
没问题！我看到你提供的这个 `Token` 结构了。

```go
type Token struct {
    Id           int    `json:"id"`
    UserId       int    `json:"user_id"`
    Key          string `json:"key" gorm:"uniqueIndex"`
    Status       int    `json:"status" gorm:"default:1"`
    Name         string `json:"name" gorm:"index" `
    CreatedTime  int64  `json:"created_time" gorm:"bigint"`
    AccessedTime int64  `json:"accessed_time" gorm:"bigint"`
}
```

我注意到这个结构和我们之前讨论的（`思路.md`）最大的不同是：它**没有 `channel_id` 字段**。

这说明你的思路发生了变化。你不再想让一个令牌（Token）**永久绑定**到*某一个*渠道（Channel）上。相反，这个 `Token` 结构更像是一个“通行证”，它只负责证明“你是谁”（认证），而不关心你“要去哪”（路由）。

这个设计引入了 `UserId`，说明你正在为未来的多用户系统打基础，非常棒！

-----

根据你的这个新设计，我们必须**重写 MVP3 的用户故事和验收标准**。原来的故事 已经不适用了。

这是我基于你的新 `Token` 结构，为你重构的 MVP3：

# (新) MVP3 - 认证与渠道池

## (新) 用户故事 - 使用令牌调用中继服务

* 标题：通过令牌（Token）访问渠道池
* 概述：作为 API 的最终用户，我想要在请求中提供一个认证令牌（Key），服务能够验证我的令牌是有效的（Status == 1），然后从所有可用的渠道（Channel）中自动选择一个来处理我的请求。所以我可以方便地使用这个中继服务，而无需关心后端有多少个渠道、或者它们具体的 API Key 是什么。

## (新) 验收标准 - 成功与失败的定义

前提：

1. 你已经在 model/main.go 中添加了 Token 结构，并成功执行了 AutoMigrate。
2. 你的 channels 表中已经有（通过 MVP2 的 API）创建好的渠道数据。
3. 你需要一个（暂时的）方法来向 tokens 表中添加数据（比如在 main.go 启动时创建，或一个简单的内部 API）。

-----

1. 正常场景 (成功转发)

    * 给定：channels 表中有两个渠道："渠道A" (key: sk-aaa) 和 "渠道B" (key: sk-bbb)。
    * 并且：tokens 表中有一个令牌：Name="主力令牌", Key="sk-nexus-abc", Status=1 (启用)。
    * 当：我向 /v1/chat/completions 发送一个合法的请求，并在请求头中加入 Authorization: Bearer sk-nexus-abc。
    * 那么：服务验证 sk-nexus-abc 是一个状态为“启用”的有效令牌。
    * 并且：服务从 channels 表中获取所有可用渠道，并选择一个（例如："渠道A"）。
    * 并且：服务使用 "渠道A" 的 sk-aaa 密钥成功向上游 API 发起请求，并将结果返回给我。

2. 异常场景 1 (令牌无效或不存在)

    * 给定：我的服务在本地运行。
    * 当：我发送一个请求，但其 Authorization 请求头中的令牌是一个不存在的（例如 Bearer sk-fake-token）。
    * 那么：服务返回一个表示“认证失败”的 HTTP 401 Unauthorized 错误码和信息。

3. 异常场景 2 (令牌被禁用)

    * 给定：tokens 表中有一个令牌：Name="已禁用", Key="sk-nexus-disabled", Status=0 (禁用)。
    * 当：我使用 Authorization: Bearer sk-nexus-disabled 发起请求。
    * 那么：服务返回一个表示“认证失败”或“令牌已禁用”的 HTTP 401 Unauthorized 错误码和信息。

4. 异常场景 3 (没有可用的渠道)

    * 给定：tokens 表中有一个有效且启用的令牌 sk-nexus-abc。
    * 但是：channels 表中没有任何数据（即 MVP2 中的渠道都被删除了）。
    * 当：我使用 sk-nexus-abc 发起请求。
    * 那么：服务认证令牌通过，但在尝试获取渠道时失败。
    * 并且：服务返回一个表示“服务配置错误”或“无可用渠道”的 HTTP 500 Internal Server Error 错误码和信息。

5. 异常场景 4 (渠道本身的 Key 失效)

    * 给定：tokens 表中有有效的令牌 sk-nexus-abc。
    * 并且：channels 表中只有一个渠道 "渠道C"，但它的 Key (sk-ccc) 是一个错误或失效的上游 Key。
    * 当：我使用 sk-nexus-abc 发起请求。
    * 那么：服务认证通过，并选择了 "渠道C" 进行转发。
    * 并且：上游 API 返回鉴权失败，服务将这个失败信息正确地中继给我（这复用了 MVP1 的异常场景）。

-----

### (新) 教练的提示：

* 为什么是这个 MVP？
  这个 MVP 将你的项目从“固定转发器”（MVP1）和“渠道管理器”（MVP2） 整合为了一个真正的“动态中继平台”。它实现了认证（Authentication）和服务发现（Service Discovery）的解耦。
* 关注点：
    1. 数据模型：你需要创建 model/token.go 文件，定义 Token 结构，并在 model/main.go 中 AutoMigrate 它。
    2. 认证中间件：这是核心！你需要创建一个新的中间件（例如 middleware/auth.go）。它的职责是：
        * 从 Authorization 头解析出 Key。
        * 查询 tokens 数据库，检查 Key 是否存在，以及 Status 是否为 1。
        * 如果验证失败，立即返回 401 错误。
        * 如果验证通过，将令牌信息（甚至用户信息）存入 Gin 的上下文（Context），以便后续使用。
    3. 改造转发逻辑：修改 controller/chat_completions.go。
        * 它不再从环境变量读取 ApiKey。
        * 它需要从 model.GetAllChannels() 获取所有渠道。
        * 它需要实现一个最简单的“负载均衡”策略（例如：目前，先写死，就用第一个渠道 channels[0]）。
        * 它使用 channels[0].Key 来替换原来硬编码的 v.ApiKey。
    4. 改造 main.go：
        * 移除启动时对 API_KEY 和 FORWARD_HOST 的依赖。FORWARD_HOST 应该成为 Channel 模型的一部分（提示：你可能需要给 Channel 加一个 Host 字段），或者暂时硬编码。
        * 为 /v1/chat/completions 路由组应用你新写的“认证中间件”。

这个新 MVP 方案更贴近一个真实项目的演进路径。祝你编码愉快！                                                                                                   