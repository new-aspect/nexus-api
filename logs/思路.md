## MVP1 - 核心中继验证

### 用户故事 - 验证核心中继

* 标题：硅基流动 API 转发
* 概述：作为本地开发者，我想要调用我的中继服务并使用硅基流动API Key, 所以我可以验证nexus-api的核心转发机制的技术可行性。补充openai的API因为区域问题不方便，所以选用硅基流动API

### 验收标准 - 成功与失败的定义

1. 正常场景
   * 我的服务在本地运行，硬编码或配置了有效的硅基流动 API Key。
   * 当我向 http://localhost:3000/v1/chat/completions 发送一个合法的请求。
   * 那么服务成功返回一个包含模型回复的 JSON 响应。

2. 异常场景 1 (Key 错误)：
   * 我的服务在本地运行，硬编码或配置了无效的硅基流动 API Key
   * 我向服务发送请求。
   * 服务返回一个表示“鉴权失败”或“无效 Key”的 HTTP 错误码和信息。

3. 异常场景 2 (请求体错误)：
   * 给定：我的服务在本地运行。
   * 当：我发送一个缺少 messages 字段的非法请求。
   * 那么：服务返回一个表示“请求体格式错误”的 HTTP 400 错误码。

---                     

## MVP2 - 渠道管理

### 用户故事 - 验证核心中继
* 标题：API 渠道的增删改查
* 概述：作为服务管理员，我想要通过API来添加、查看、更新和删除不同的上游渠道（比如不同的模型供应商或同一个提供商的不同key）,所以我可以灵活的配置和管理服务，为未来多渠道路由和负载均衡做准备

### 验收标准 - 成功与失败的定义
1. 正常场景 1 (创建渠道)
   * 给定：我的服务在本地运行
   * 当：我想/api/channel发送一个POST请求，请求体包含一个渠道的必要信息（例如：type:"OpenAI",name:"我的备用key",key:"sk-xxxx"）
   * 那么：服务成功在数据库中创建一个新的渠道记录，并返回一个表示成功的 HTTP 状态码（201 Created）和新创建渠道的信息（不应包含完整的 key）。

2. 正常场景 2 (获取渠道列表)
   * 给定：服务中已经存在几个渠道。
   * 当：我向 /api/channel 发送一个 GET 请求。
   * 那么：服务成功返回一个包含所有渠道信息的列表。出于安全考虑，列表中的每个渠道 key 字段都应该是被遮蔽的（例如：sk-xxxx...xxxx）。

3. 正常场景 3 (更新渠道)
   * 给定：服务中已存在一个 ID 为 1 的渠道。
   * 当：我向 /api/channel/1 发送一个 PUT 请求，请求体中包含需要更新的字段（例如：{ "name": "我的主力Key" }）。
   * 那么：服务成功更新该渠道的信息，并返回更新后的渠道信息。

4. 正常场景 4 (删除渠道)
   * 给定：服务中已存在一个 ID 为 1 的渠道。
   * 当：我向 /api/channel/1 发送一个 DELETE 请求。
   * 那么：服务成功地从数据库中删除该渠道，并返回一个表示成功的 HTTP 状态码（204 No Content）。

5. 异常场景 1 (创建渠道时缺少关键信息)
   * 给定：我的服务在本地运行。
   * 当：我发送一个创建渠道的 POST 请求，但请求体中缺少了 key 字段。
   * 那么：服务返回一个表示“请求体格式错误”的 HTTP 400 错误码和相应的错误信息。
     
提示：
* 为什么是这个 MVP？ 这个步骤将你的项目从一个“写死的转发器”变成了一个“可配置的转发平台”的雏形。它引入了数据库操作和基础的 CRUD API，这是构建更复杂功能（如用户系统、令牌管理等）的基石。
* 关注点：在这个阶段，你的重点是实现渠道模型的定义、数据库的连接与操作、以及一套完整的 RESTful API。暂时还不需要让转发逻辑（MVP1 的功能）立即用上这些渠道，我们先把管理功能做好。
* 下一步是什么？ 当这个 MVP 完成后，下一个自然的步骤（MVP3）就是将 MVP1 和 MVP2 连接起来：修改你的核心中继逻辑，使其不再使用硬编码的 Key，而是能够根据请求的某些规则（例如请求头中的认证信息）从数据库中选择一个合适的渠道进行转发。

---
太棒了！恭喜你完成了 MVP2，你的项目现在已经从一个简单的“转发器”演进成了一个具备基础管理能力的“平台”了。这为我们接下来的工作打下了坚实的基础。

现在，我们要做的就是把 MVP1（核心转发）和 MVP2（渠道管理）这两个独立的功能模块连接起来，让它们真正协同工作。这正是 MVP3 的核心任务。

---
# MVP3 - 令牌与动态路由

## 用户故事 - 使用令牌调用特定渠道

* 标题：通过令牌（Token）使用指定的 API 渠道
* 概述：作为 API 的最终用户，我想要在请求中提供一个认证令牌，服务能够根据这个令牌找到并使用其背后绑定的、有效的 API 渠道（如硅基流动、OpenAI 等）来处理我的请求，所以我可以方便地使用这个中继服务，而无需关心具体的上游 API Key。

## 验收标准 - 成功与失败的定义

1.  正常场景 (成功转发)
   * 给定：服务数据库中存在一个渠道（Channel A），并且有一个令牌（Token X）被创建并明确指向了渠道 A。
   * 当：我向 `/v1/chat/completions` 发送一个合法的请求，并在请求头中加入了 `Authorization: Bearer Token X`。
   * 那么：服务验证 Token X 有效，找到关联的渠道 A，使用渠道 A 的 Key 成功向上游 API 发起请求，并将结果返回给我。

2.  异常场景 1 (令牌无效或不存在)
   * 给定：我的服务在本地运行。
   * 当：我发送一个请求，但其 `Authorization` 请求头中的令牌是一个不存在的、伪造的令牌。
   * 那么：服务返回一个表示“认证失败”的 HTTP 401 Unauthorized 错误码和信息。

3.  异常场景 2 (令牌关联的渠道被禁用或删除)
   * 给定：服务中存在一个令牌 Token Y，它关联的渠道 B 已经被管理员设置为“禁用”状态或已被删除。
   * 当：我使用 Token Y 发起请求。
   * 那么：服务返回一个表示“渠道不可用”的 HTTP 400 Bad Request 或类似的错误码和信息。

4.  异常场景 3 (渠道本身的 Key 失效)
   * 给定：令牌 Token Z 关联的渠道 C 是有效的，但我（管理员）在渠道管理中为渠道 C 配置了一个错误的 API Key。
   * 当：我使用 Token Z 发起请求。
   * 那么：服务会尝试向上游转发，但上游 API 会返回鉴权失败。服务应将这个失败信息正确地中继给我（这其实复用了 MVP1 的异常场景 1，但触发路径不同了）。

---                                                                                                                                                                            

### 教练的提示：

* 为什么是这个 MVP？这是你的项目实现其核心价值的关键一步。它将管理后台（MVP2）和核心转发功能（MVP1）彻底打通，使得你的服务真正地“动态”和“可用”起来。从此，你的服务不再依赖任何硬编码的配置，而是由数据库中的数据驱动。
* 关注点：
   1.  数据模型：你需要设计并创建一个新的数据表 `tokens`。这个表至少需要包含令牌本身（一个随机字符串）、关联的渠道 ID (`channel_id`)，以及一个状态字段（例如 `status`：启用/禁用）。
   2.  认证中间件：这是本次 MVP 的核心代码。你需要创建一个新的中间件（例如在 `middleware/auth.go` 中），它的职责是：
      * 从请求头 `Authorization` 中解析出令牌。
      * 查询数据库，验证令牌是否存在且状态为“启用”。
      * 如果验证通过，就从数据库中加载该令牌关联的渠道信息。
      * 将渠道信息存入请求的上下文（Context）中，以便后续的处理函数（Handler）可以获取到。
   3.  改造转发逻辑：修改 MVP1 中的核心转发控制器（例如 `controller/relay.go`）。它不再读取硬编码的 Key，而是从请求的上下文中读取由认证中间件注入的渠道信息，并使用该渠道的 Key 来进行转发。
* 下一步是什么？完成 MVP3 后，你的 API 中继服务已经基本成型了！接下来的 MVP4 就可以朝着更高级的管理功能演进了，比如：
   * 用户系统：一个用户可以拥有多个令牌。
   * 令牌额度管理：为每个令牌设置请求次数或金额限制。
   * 多渠道负载均衡：一个令牌可以关联一个渠道组，请求会根据某种策略（如轮询、随机）分发到组内的不同渠道。

这个挑战比 MVP2 更大，因为它涉及到模块间的交互和请求生命周期管理。祝你编码愉快，期待你完成 MVP3 的好消息！                                                                                                                    